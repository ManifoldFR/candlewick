#pragma clang diagnostic ignored "-Wmissing-prototypes"

#include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

struct CameraParams
{
    int mode;
    float near;
    float far;
};

struct main0_out
{
    float4 outColor [[color(0)]];
};

struct main0_in
{
    float2 inUV [[user(locn0)]];
};

static inline __attribute__((always_inline))
float linearizeDepth(thread const float& depth, thread const float& near, thread const float& far)
{
    float z_ndc = (2.0 * depth) - 1.0;
    return ((2.0 * near) * far) / ((far + near) - (z_ndc * (far - near)));
}

static inline __attribute__((always_inline))
float3 visualizeDepthGrayscale(thread const float& depth, constant CameraParams& _48)
{
    float param = depth;
    float param_1 = _48.near;
    float param_2 = _48.far;
    float lin = linearizeDepth(param, param_1, param_2);
    float norm = (lin - _48.near) / (_48.far - _48.near);
    return float3(norm);
}

static inline __attribute__((always_inline))
float3 visualizeDepthHeatmap(thread const float& depth, constant CameraParams& _48)
{
    float param = depth;
    float param_1 = _48.near;
    float param_2 = _48.far;
    float linear_depth = linearizeDepth(param, param_1, param_2);
    float normalized = (linear_depth - _48.near) / (_48.far - _48.near);
    float3 color;
    if (normalized < 0.25)
    {
        float t = normalized / 0.25;
        color = mix(float3(0.0, 0.0, 1.0), float3(0.0, 1.0, 1.0), float3(t));
    }
    else
    {
        if (normalized < 0.5)
        {
            float t_1 = (normalized - 0.25) / 0.25;
            color = mix(float3(0.0, 1.0, 1.0), float3(0.0, 1.0, 0.0), float3(t_1));
        }
        else
        {
            if (normalized < 0.75)
            {
                float t_2 = (normalized - 0.5) / 0.25;
                color = mix(float3(0.0, 1.0, 0.0), float3(1.0, 1.0, 0.0), float3(t_2));
            }
            else
            {
                float t_3 = (normalized - 0.75) / 0.25;
                color = mix(float3(1.0, 1.0, 0.0), float3(1.0, 0.0, 0.0), float3(t_3));
            }
        }
    }
    return color;
}

fragment main0_out main0(main0_in in [[stage_in]], constant CameraParams& _48 [[buffer(0)]], texture2d<float> depthTex [[texture(0)]], sampler depthTexSmplr [[sampler(0)]])
{
    main0_out out = {};
    float depth = depthTex.sample(depthTexSmplr, in.inUV).x;
    float3 color;
    switch (_48.mode)
    {
        case 0:
        {
            float param = depth;
            color = visualizeDepthGrayscale(param, _48);
            break;
        }
        case 1:
        {
            float param_1 = depth;
            color = visualizeDepthHeatmap(param_1, _48);
            break;
        }
    }
    out.outColor.x = color.x;
    out.outColor.y = color.y;
    out.outColor.z = color.z;
    out.outColor.w = 1.0;
    return out;
}
